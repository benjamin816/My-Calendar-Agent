
import { NextRequest, NextResponse } from 'next/server';
import { siriStorage } from '@/services/siriStorage';

/**
 * SIRI SHORTCUT WEBHOOK (ROBUST VERSION)
 * 
 * Handles multiple payload formats from iOS Shortcuts:
 * 1. JSON (with varying keys and value types)
 * 2. Form Data (application/x-www-form-urlencoded)
 * 3. Raw Text (Entire body is the command)
 */
export async function POST(req: NextRequest) {
  try {
    // 1. AUTHENTICATION
    const siriKey = req.headers.get('x-chronos-key');
    const secret = process.env.CHRONOS_SIRI_KEY;

    if (!secret || siriKey !== secret) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const contentType = req.headers.get('content-type') || '';
    const bodyText = await req.text();
    
    let extractedText: string | null = null;
    let diagnosticInfo: any = {
      contentType,
      bodyPreview: bodyText.substring(0, 100),
      bodyLength: bodyText.length
    };

    // 2. EXTRACTION LOGIC
    
    // Attempt 1: Try JSON Parsing (The most common format for modern shortcuts)
    if (bodyText.trim().startsWith('{')) {
      try {
        const json = JSON.parse(bodyText);
        diagnosticInfo.parsedAs = 'json';
        
        // Check a list of likely keys (Shortcuts can be inconsistent with casing or key names)
        const possibleKeys = ['text', 'Text', 'dictatedText', 'dictated', 'command', 'message', 'body', 'input'];
        for (const key of possibleKeys) {
          const val = json[key];
          if (val) {
            if (typeof val === 'string' && val.trim()) {
              extractedText = val.trim();
              break;
            } else if (typeof val === 'object' && val !== null) {
              // Handle "Rich Text" objects sometimes generated by Siri
              const innerText = val.text || val.string || val.content || val.value;
              if (typeof innerText === 'string' && innerText.trim()) {
                extractedText = innerText.trim();
                break;
              }
            }
          }
        }

        // If it's a JSON array or string root
        if (!extractedText && typeof json === 'string') {
          extractedText = json.trim();
        }
      } catch (e) {
        diagnosticInfo.jsonError = (e as Error).message;
      }
    }

    // Attempt 2: Try Form Data (application/x-www-form-urlencoded)
    if (!extractedText && (contentType.includes('form') || bodyText.includes('='))) {
      try {
        const params = new URLSearchParams(bodyText);
        const possibleKeys = ['text', 'Text', 'dictatedText', 'command', 'input'];
        for (const key of possibleKeys) {
          const val = params.get(key);
          if (val && val.trim()) {
            extractedText = val.trim();
            diagnosticInfo.parsedAs = 'form-data';
            break;
          }
        }
      } catch (e) {}
    }

    // Attempt 3: Fallback to Raw Text (Entire body is the command)
    if (!extractedText && bodyText.trim()) {
      // Only use raw text if it doesn't look like corrupted/partial JSON
      if (!bodyText.trim().startsWith('{') || bodyText.length < 5) {
        extractedText = bodyText.trim();
        diagnosticInfo.parsedAs = 'raw-text';
      }
    }

    // 3. FINAL VALIDATION & STORAGE
    if (!extractedText) {
      console.warn("[Siri Webhook] Failed to extract text:", diagnosticInfo);
      return NextResponse.json({ 
        error: "Missing dictated text",
        debug: diagnosticInfo 
      }, { status: 400 });
    }

    // Store the message for the frontend to pick up
    siriStorage.push(extractedText);

    return NextResponse.json({ 
      ok: true,
      extracted: extractedText.substring(0, 20) + "..."
    });
    
  } catch (error: any) {
    console.error("Siri Webhook Critical Error:", error);
    return NextResponse.json({ error: error.message || "Internal Server Error" }, { status: 500 });
  }
}
